-- ==============================
-- SCRIPT PRINCIPAL DE EXECUTIE
-- ==============================

--@03_schema_objects.sql
--@04_insert_data.sql
--@05_views.sql
--@06_materialized_views.sql
--@07_queries_group_by.sql
--@08_analytic_functions.sql



-- ==============================
-- SCRIPT COMPLET DE RESET + CREARE SCHEMA
-- Partea 1 se ruleaza ca SYS
-- Partea 2 se ruleaza ca userul `davax_dev`
-- ==============================

-- =======================================================
-- PARTEA 1: ADMIN - CA SYS (creeaza userul, tablespace-uri)
-- =======================================================

-- Sterge utilizatorul, daca exista
DROP USER davax_dev CASCADE;

-- Stergere tablespace-uri cu fisierele atasate
DROP TABLESPACE davax_data INCLUDING CONTENTS AND DATAFILES;
DROP TABLESPACE davax_index INCLUDING CONTENTS AND DATAFILES;
DROP TABLESPACE davax_partition INCLUDING CONTENTS AND DATAFILES;
DROP TABLESPACE davax_archive INCLUDING CONTENTS AND DATAFILES;
DROP TABLESPACE davax_audit INCLUDING CONTENTS AND DATAFILES;

-- Creare tablespace-uri cu fisiere noi
CREATE TABLESPACE davax_data DATAFILE 'davax_data_v2.dbf' SIZE 100M AUTOEXTEND ON NEXT 10M EXTENT MANAGEMENT LOCAL;
CREATE TABLESPACE davax_index DATAFILE 'davax_index_v2.dbf' SIZE 50M AUTOEXTEND ON NEXT 5M EXTENT MANAGEMENT LOCAL;
CREATE TABLESPACE davax_partition DATAFILE 'davax_partition_v2.dbf' SIZE 200M AUTOEXTEND ON NEXT 20M EXTENT MANAGEMENT LOCAL;
CREATE TABLESPACE davax_archive DATAFILE 'davax_archive_v2.dbf' SIZE 100M AUTOEXTEND ON NEXT 10M EXTENT MANAGEMENT LOCAL;
CREATE TABLESPACE davax_audit DATAFILE 'davax_audit_v2.dbf' SIZE 50M AUTOEXTEND ON NEXT 5M EXTENT MANAGEMENT LOCAL;

-- Creare utilizator
CREATE USER davax_dev IDENTIFIED BY dev_pass DEFAULT TABLESPACE davax_data TEMPORARY TABLESPACE temp;

GRANT CONNECT, RESOURCE TO davax_dev;

-- Alocare QUOTA pe tablespace-uri
ALTER USER davax_dev QUOTA UNLIMITED ON davax_data;
ALTER USER davax_dev QUOTA UNLIMITED ON davax_index;
ALTER USER davax_dev QUOTA UNLIMITED ON davax_partition;
ALTER USER davax_dev QUOTA UNLIMITED ON davax_archive;
ALTER USER davax_dev QUOTA UNLIMITED ON davax_audit;

-- Permisiuni pentru view-uri
GRANT CREATE VIEW TO davax_dev;
GRANT CREATE MATERIALIZED VIEW TO davax_dev;

-- =======================================================
-- PARTEA 2: SCHEMA SETUP - CA DAVAX_DEV
-- =======================================================

-- ==============================
-- 1. CREARE TABELE
-- ==============================

CREATE TABLE Employees (
    employee_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name VARCHAR2(50) NOT NULL,
    last_name VARCHAR2(50) NOT NULL,
    email VARCHAR2(100) UNIQUE NOT NULL,
    hire_date DATE DEFAULT SYSDATE NOT NULL,
    is_active CHAR(1) DEFAULT 'Y' CHECK (is_active IN ('Y', 'N'))
) TABLESPACE davax_data;

CREATE TABLE Projects (
    project_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(100) NOT NULL,
    description CLOB,
    start_date DATE NOT NULL,
    end_date DATE,
    CONSTRAINT chk_end_gt_start CHECK (end_date > start_date)
) TABLESPACE davax_data;

CREATE TABLE Task_Types (
    task_type_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR2(50) UNIQUE NOT NULL,
    description VARCHAR2(200)
) TABLESPACE davax_data;

CREATE TABLE Timesheets (
    timesheet_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    employee_id NUMBER NOT NULL,
    project_id NUMBER NOT NULL,
    task_type_id NUMBER NOT NULL,
    work_date DATE NOT NULL,
    hours_worked NUMBER(4,2) NOT NULL CHECK (hours_worked > 0),
    notes CLOB CHECK (notes IS JSON),
    CONSTRAINT fk_employee FOREIGN KEY (employee_id) REFERENCES Employees(employee_id),
    CONSTRAINT fk_project FOREIGN KEY (project_id) REFERENCES Projects(project_id),
    CONSTRAINT fk_task_type FOREIGN KEY (task_type_id) REFERENCES Task_Types(task_type_id)
) TABLESPACE davax_data;

CREATE TABLE Timesheet_Audit (
    audit_id NUMBER GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    timesheet_id NUMBER,
    action_type VARCHAR2(10) CHECK (action_type IN ('INSERT', 'UPDATE', 'DELETE')),
    action_time TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    performed_by VARCHAR2(100),
    old_data CLOB,
    CONSTRAINT fk_ts_audit FOREIGN KEY (timesheet_id) REFERENCES Timesheets(timesheet_id)
) TABLESPACE davax_audit;

-- ==============================
-- 2. INDEXURI
-- ==============================

CREATE INDEX idx_timesheets_employee_date ON Timesheets(employee_id, work_date) TABLESPACE davax_index;
CREATE INDEX idx_lower_email ON Employees(LOWER(email)) TABLESPACE davax_index;
CREATE INDEX idx_project ON Timesheets(project_id) TABLESPACE davax_index;

-- ==============================
-- 3. TRIGGER VALIDARE DATA
-- ==============================

CREATE OR REPLACE TRIGGER trg_timesheet_workdate_check
BEFORE INSERT OR UPDATE ON Timesheets
FOR EACH ROW
BEGIN
  IF :NEW.work_date > SYSDATE THEN
    RAISE_APPLICATION_ERROR(-20001, 'work_date cannot be in the future.');
  END IF;
END;
/

-- ==============================
-- 4. INSERARE DATE
-- ==============================

-- Angajați
BEGIN
  FOR i IN 1..1000 LOOP
    INSERT INTO Employees (first_name, last_name, email)
    VALUES ('First_' || i, 'Last_' || i, LOWER('user_' || i || '@davax.com'));
  END LOOP;
  COMMIT;
END;
/

-- Proiecte
BEGIN
  FOR i IN 1..20 LOOP
    INSERT INTO Projects (name, description, start_date, end_date)
    VALUES (
      'Project_' || i,
      'Generated project ' || i,
      TRUNC(SYSDATE - DBMS_RANDOM.VALUE(100, 1000)),
      TRUNC(SYSDATE - DBMS_RANDOM.VALUE(10, 99))
    );
  END LOOP;
  COMMIT;
END;
/

-- Task Types
BEGIN
  FOR i IN 1..10 LOOP
    INSERT INTO Task_Types (name, description)
    VALUES ('TaskType_' || i, 'Task type generated ' || i);
  END LOOP;
  COMMIT;
END;
/

-- Procedura pentru Timesheets
CREATE OR REPLACE PROCEDURE insert_random_timesheets(p_count NUMBER DEFAULT 1000) AS
BEGIN
  FOR i IN 1..p_count LOOP
    DECLARE
      v_employee_id  NUMBER;
      v_project_id   NUMBER;
      v_task_type_id NUMBER;
      v_work_date    DATE;
      v_hours        NUMBER(4,2);
      v_task_name    VARCHAR2(50);
      v_emp_name     VARCHAR2(100);
      v_project_name VARCHAR2(100);
      v_remote       VARCHAR2(5);
      v_approval     VARCHAR2(10);
      v_start_time   VARCHAR2(5);
      v_end_time     VARCHAR2(5);
      v_json         CLOB;
    BEGIN
      SELECT employee_id INTO v_employee_id FROM (SELECT employee_id FROM Employees ORDER BY DBMS_RANDOM.VALUE) WHERE ROWNUM = 1;
      SELECT project_id, name INTO v_project_id, v_project_name FROM (SELECT project_id, name FROM Projects ORDER BY DBMS_RANDOM.VALUE) WHERE ROWNUM = 1;
      SELECT task_type_id, name INTO v_task_type_id, v_task_name FROM (SELECT task_type_id, name FROM Task_Types ORDER BY DBMS_RANDOM.VALUE) WHERE ROWNUM = 1;
      SELECT first_name || ' ' || last_name INTO v_emp_name FROM Employees WHERE employee_id = v_employee_id;

      v_work_date := TRUNC(SYSDATE - DBMS_RANDOM.VALUE(1, 60));
      v_hours := ROUND(DBMS_RANDOM.VALUE(1, 8), 2);
      v_remote := CASE TRUNC(DBMS_RANDOM.VALUE(0, 2)) WHEN 1 THEN 'true' ELSE 'false' END;
      v_approval := CASE TRUNC(DBMS_RANDOM.VALUE(1, 4)) WHEN 1 THEN 'approved' WHEN 2 THEN 'pending' ELSE 'rejected' END;
      v_start_time := TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(8, 11))) || ':00';
      v_end_time := TO_CHAR(TRUNC(DBMS_RANDOM.VALUE(16, 19))) || ':00';

      v_json := '{"note": "' || v_task_name || '", "employee": "' || v_emp_name || '", "project": "' || v_project_name || '", "remote": ' || v_remote || ', "approval": "' || v_approval || '", "duration": {"start": "' || v_start_time || '", "end": "' || v_end_time || '"}}';

      INSERT INTO Timesheets (employee_id, project_id, task_type_id, work_date, hours_worked, notes)
      VALUES (v_employee_id, v_project_id, v_task_type_id, v_work_date, v_hours, v_json);
    END;
  END LOOP;
  COMMIT;
END insert_random_timesheets;
/

BEGIN
  insert_random_timesheets(1000);
END;
/

-- ==============================
-- 5. VIEW-uri
-- ==============================

CREATE OR REPLACE VIEW vw_employee_total_hours AS
SELECT e.employee_id, e.first_name || ' ' || e.last_name AS full_name, SUM(t.hours_worked) AS total_hours
FROM Employees e
JOIN Timesheets t ON e.employee_id = t.employee_id
GROUP BY e.employee_id, e.first_name, e.last_name;

CREATE OR REPLACE VIEW vw_project_activity AS
SELECT p.project_id, p.name AS project_name, COUNT(t.timesheet_id) AS total_entries, SUM(t.hours_worked) AS total_hours
FROM Projects p
LEFT JOIN Timesheets t ON p.project_id = t.project_id
GROUP BY p.project_id, p.name;

CREATE OR REPLACE VIEW vw_daily_summary AS
SELECT work_date, COUNT(*) AS total_entries, SUM(hours_worked) AS total_hours, ROUND(AVG(hours_worked), 2) AS avg_hours
FROM Timesheets
GROUP BY work_date
ORDER BY work_date;

-- ==============================
-- 6. MATERIALIZED VIEW-uri
-- ==============================

CREATE MATERIALIZED VIEW my_rejected_tasks_per_employee
BUILD IMMEDIATE REFRESH COMPLETE
START WITH SYSDATE NEXT SYSDATE + 1
AS
SELECT employee_id, work_date, COUNT(*) AS rejected_tasks
FROM Timesheets
WHERE JSON_VALUE(notes, '$.approval') = 'rejected'
GROUP BY employee_id, work_date;

CREATE MATERIALIZED VIEW total_hours_employee_per_month
BUILD IMMEDIATE REFRESH COMPLETE
AS
SELECT employee_id, TRUNC(work_date, 'MM') AS month, SUM(hours_worked) AS total_hours
FROM Timesheets
GROUP BY employee_id, TRUNC(work_date, 'MM');

CREATE MATERIALIZED VIEW mv_remote_vs_onsite
BUILD IMMEDIATE REFRESH COMPLETE
START WITH SYSDATE NEXT SYSDATE + 1
AS
SELECT JSON_VALUE(notes, '$.remote') AS remote_flag, COUNT(*) AS task_count, ROUND(AVG(hours_worked), 2) AS avg_hours
FROM Timesheets
GROUP BY JSON_VALUE(notes, '$.remote');

-- ==============================
-- 7. SELECTURI CU GROUP BY
-- ==============================

SELECT e.employee_id, SUM(t.hours_worked) AS total_hours
FROM Employees e
JOIN Timesheets t ON e.employee_id = t.employee_id
GROUP BY e.employee_id
ORDER BY total_hours;

SELECT tt.name AS task_type, COUNT(*) AS total_tasks
FROM Timesheets t
JOIN Task_Types tt ON t.task_type_id = tt.task_type_id
GROUP BY tt.name
ORDER BY total_tasks DESC;

SELECT TRUNC(hire_date, 'MM') AS hire_month, COUNT(*) AS total_hired
FROM Employees
GROUP BY TRUNC(hire_date, 'MM')
ORDER BY hire_month;

-- ==============================
-- 8. FUNCȚII ANALITICE (fara row_number)
-- ==============================

SELECT employee_id, work_date, hours_worked,
       SUM(hours_worked) OVER (PARTITION BY employee_id ORDER BY work_date) AS cumulative_hours
FROM Timesheets
ORDER BY employee_id, work_date;
